/// Generated by the Protocol Buffers 3.3.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.16
/// Source file "voip.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct VoipRoot {
    public static let `default` = VoipRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Text : GeneratedMessage {

    public static func == (lhs: Text, rhs: Text) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
        fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var from:String! = nil
    public fileprivate(set) var hasFrom:Bool = false

    public fileprivate(set) var to:String! = nil
    public fileprivate(set) var hasTo:Bool = false

    public fileprivate(set) var body:Data! = nil
    public fileprivate(set) var hasBody:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasFrom {
            try codedOutputStream.writeString(fieldNumber: 1, value:from)
        }
        if hasTo {
            try codedOutputStream.writeString(fieldNumber: 2, value:to)
        }
        if hasBody {
            try codedOutputStream.writeData(fieldNumber: 3, value:body)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFrom {
            serialize_size += from.computeStringSize(fieldNumber: 1)
        }
        if hasTo {
            serialize_size += to.computeStringSize(fieldNumber: 2)
        }
        if hasBody {
            serialize_size += body.computeDataSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Text.Builder {
        return Text.classBuilder() as! Text.Builder
    }
    public func getBuilder() -> Text.Builder {
        return classBuilder() as! Text.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Text.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Text.Builder()
    }
    public func toBuilder() throws -> Text.Builder {
        return try Text.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Text) throws -> Text.Builder {
        return try Text.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasFrom {
            jsonMap["from"] = from
        }
        if hasTo {
            jsonMap["to"] = to
        }
        if hasBody {
            jsonMap["body"] = body.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Text {
        return try Text.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Text {
        return try Text.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasFrom {
            output += "\(indent) from: \(from) \n"
        }
        if hasTo {
            output += "\(indent) to: \(to) \n"
        }
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasFrom {
                hashCode = (hashCode &* 31) &+ from.hashValue
            }
            if hasTo {
                hashCode = (hashCode &* 31) &+ to.hashValue
            }
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Text"
    }
    override public func className() -> String {
        return "Text"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Text = Text()
        public func getMessage() -> Text {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var from:String {
            get {
                return builderResult.from
            }
            set (value) {
                builderResult.hasFrom = true
                builderResult.from = value
            }
        }
        public var hasFrom:Bool {
            get {
                return builderResult.hasFrom
            }
        }
        @discardableResult
        public func setFrom(_ value:String) -> Text.Builder {
            self.from = value
            return self
        }
        @discardableResult
        public func clearFrom() -> Text.Builder{
            builderResult.hasFrom = false
            builderResult.from = nil
            return self
        }
        public var to:String {
            get {
                return builderResult.to
            }
            set (value) {
                builderResult.hasTo = true
                builderResult.to = value
            }
        }
        public var hasTo:Bool {
            get {
                return builderResult.hasTo
            }
        }
        @discardableResult
        public func setTo(_ value:String) -> Text.Builder {
            self.to = value
            return self
        }
        @discardableResult
        public func clearTo() -> Text.Builder{
            builderResult.hasTo = false
            builderResult.to = nil
            return self
        }
        public var body:Data {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:Data) -> Text.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> Text.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Text.Builder {
            builderResult = Text()
            return self
        }
        override public func clone() throws -> Text.Builder {
            return try Text.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Text {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Text {
            let returnMe:Text = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Text) throws -> Text.Builder {
            if other == Text() {
                return self
            }
            if other.hasFrom {
                from = other.from
            }
            if other.hasTo {
                to = other.to
            }
            if other.hasBody {
                body = other.body
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Text.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Text.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    from = try codedInputStream.readString()

                case 18:
                    to = try codedInputStream.readString()

                case 26:
                    body = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Text.Builder {
            let resultDecodedBuilder = Text.Builder()
            if let jsonValueFrom = jsonMap["from"] as? String {
                resultDecodedBuilder.from = jsonValueFrom
            }
            if let jsonValueTo = jsonMap["to"] as? String {
                resultDecodedBuilder.to = jsonValueTo
            }
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = Data(base64Encoded:jsonValueBody, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Text.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Text.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class File : GeneratedMessage {

    public static func == (lhs: File, rhs: File) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSequence == rhs.hasSequence) && (!lhs.hasSequence || lhs.sequence == rhs.sequence)
        fieldCheck = fieldCheck && (lhs.hasTotalSize == rhs.hasTotalSize) && (!lhs.hasTotalSize || lhs.totalSize == rhs.totalSize)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var sequence:UInt64! = nil
    public fileprivate(set) var hasSequence:Bool = false

    public fileprivate(set) var totalSize:UInt64! = nil
    public fileprivate(set) var hasTotalSize:Bool = false

    public fileprivate(set) var body:Data! = nil
    public fileprivate(set) var hasBody:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSequence {
            try codedOutputStream.writeUInt64(fieldNumber: 1, value:sequence)
        }
        if hasTotalSize {
            try codedOutputStream.writeUInt64(fieldNumber: 2, value:totalSize)
        }
        if hasBody {
            try codedOutputStream.writeData(fieldNumber: 3, value:body)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSequence {
            serialize_size += sequence.computeUInt64Size(fieldNumber: 1)
        }
        if hasTotalSize {
            serialize_size += totalSize.computeUInt64Size(fieldNumber: 2)
        }
        if hasBody {
            serialize_size += body.computeDataSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> File.Builder {
        return File.classBuilder() as! File.Builder
    }
    public func getBuilder() -> File.Builder {
        return classBuilder() as! File.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return File.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return File.Builder()
    }
    public func toBuilder() throws -> File.Builder {
        return try File.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:File) throws -> File.Builder {
        return try File.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasSequence {
            jsonMap["sequence"] = "\(sequence)"
        }
        if hasTotalSize {
            jsonMap["totalSize"] = "\(totalSize)"
        }
        if hasBody {
            jsonMap["body"] = body.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> File {
        return try File.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> File {
        return try File.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSequence {
            output += "\(indent) sequence: \(sequence) \n"
        }
        if hasTotalSize {
            output += "\(indent) totalSize: \(totalSize) \n"
        }
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSequence {
                hashCode = (hashCode &* 31) &+ sequence.hashValue
            }
            if hasTotalSize {
                hashCode = (hashCode &* 31) &+ totalSize.hashValue
            }
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "File"
    }
    override public func className() -> String {
        return "File"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:File = File()
        public func getMessage() -> File {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var sequence:UInt64 {
            get {
                return builderResult.sequence
            }
            set (value) {
                builderResult.hasSequence = true
                builderResult.sequence = value
            }
        }
        public var hasSequence:Bool {
            get {
                return builderResult.hasSequence
            }
        }
        @discardableResult
        public func setSequence(_ value:UInt64) -> File.Builder {
            self.sequence = value
            return self
        }
        @discardableResult
        public func clearSequence() -> File.Builder{
            builderResult.hasSequence = false
            builderResult.sequence = nil
            return self
        }
        public var totalSize:UInt64 {
            get {
                return builderResult.totalSize
            }
            set (value) {
                builderResult.hasTotalSize = true
                builderResult.totalSize = value
            }
        }
        public var hasTotalSize:Bool {
            get {
                return builderResult.hasTotalSize
            }
        }
        @discardableResult
        public func setTotalSize(_ value:UInt64) -> File.Builder {
            self.totalSize = value
            return self
        }
        @discardableResult
        public func clearTotalSize() -> File.Builder{
            builderResult.hasTotalSize = false
            builderResult.totalSize = nil
            return self
        }
        public var body:Data {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:Data) -> File.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> File.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> File.Builder {
            builderResult = File()
            return self
        }
        override public func clone() throws -> File.Builder {
            return try File.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> File {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> File {
            let returnMe:File = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:File) throws -> File.Builder {
            if other == File() {
                return self
            }
            if other.hasSequence {
                sequence = other.sequence
            }
            if other.hasTotalSize {
                totalSize = other.totalSize
            }
            if other.hasBody {
                body = other.body
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> File.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> File.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    sequence = try codedInputStream.readUInt64()

                case 16:
                    totalSize = try codedInputStream.readUInt64()

                case 26:
                    body = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> File.Builder {
            let resultDecodedBuilder = File.Builder()
            if let jsonValueSequence = jsonMap["sequence"] as? String {
                resultDecodedBuilder.sequence = UInt64(jsonValueSequence)!
            } else if let jsonValueSequence = jsonMap["sequence"] as? UInt {
                resultDecodedBuilder.sequence = UInt64(jsonValueSequence)
            }
            if let jsonValueTotalSize = jsonMap["totalSize"] as? String {
                resultDecodedBuilder.totalSize = UInt64(jsonValueTotalSize)!
            } else if let jsonValueTotalSize = jsonMap["totalSize"] as? UInt {
                resultDecodedBuilder.totalSize = UInt64(jsonValueTotalSize)
            }
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = Data(base64Encoded:jsonValueBody, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> File.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try File.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Voip : GeneratedMessage {

    public static func == (lhs: Voip, rhs: Voip) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = fieldCheck && (lhs.hasWhich == rhs.hasWhich) && (!lhs.hasWhich || lhs.which == rhs.which)
        fieldCheck = fieldCheck && (lhs.textStorage == rhs.textStorage)
        fieldCheck = fieldCheck && (lhs.hasFile == rhs.hasFile) && (!lhs.hasFile || lhs.file == rhs.file)
        fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



        //Enum type declaration start 

        /// Identifies which field is filled in
        public enum Which:Int32, GeneratedEnum {
            case text = 0
            case file = 1
            case av = 2
            public func toString() -> String {
                switch self {
                case .text: return "TEXT"
                case .file: return "FILE"
                case .av: return "AV"
                }
            }
            public static func fromString(_ str:String) throws -> Voip.Which {
                switch str {
                case "TEXT":    return .text
                case "FILE":    return .file
                case "AV":    return .av
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .text: return ".text"
                case .file: return ".file"
                case .av: return ".av"
                }
            }
            public var hashValue:Int {
                return self.rawValue.hashValue
            }
            public static func ==(lhs:Which, rhs:Which) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 

    public fileprivate(set) var version:UInt32! = nil
    public fileprivate(set) var hasVersion:Bool = false

    public fileprivate(set) var which:Voip.Which = Voip.Which.text
    public fileprivate(set) var hasWhich:Bool = false
    public fileprivate(set) var textStorage:Array<Text>  = Array<Text>()
    public fileprivate(set) var file:File!
    public fileprivate(set) var hasFile:Bool = false
    public fileprivate(set) var payload:Data! = nil
    public fileprivate(set) var hasPayload:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVersion {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:version)
        }
        if hasWhich {
            try codedOutputStream.writeEnum(fieldNumber: 2, value:which.rawValue)
        }
        for oneElementTextStorage in textStorage {
              try codedOutputStream.writeMessage(fieldNumber: 101, value:oneElementTextStorage)
        }
        if hasFile {
            try codedOutputStream.writeMessage(fieldNumber: 102, value:file)
        }
        if hasPayload {
            try codedOutputStream.writeData(fieldNumber: 103, value:payload)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVersion {
            serialize_size += version.computeUInt32Size(fieldNumber: 1)
        }
        if (hasWhich) {
            serialize_size += which.rawValue.computeEnumSize(fieldNumber: 2)
        }
        for oneElementTextStorage in textStorage {
            serialize_size += oneElementTextStorage.computeMessageSize(fieldNumber: 101)
        }
        if hasFile {
            if let varSizefile = file?.computeMessageSize(fieldNumber: 102) {
                serialize_size += varSizefile
            }
        }
        if hasPayload {
            serialize_size += payload.computeDataSize(fieldNumber: 103)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Voip.Builder {
        return Voip.classBuilder() as! Voip.Builder
    }
    public func getBuilder() -> Voip.Builder {
        return classBuilder() as! Voip.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Voip.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Voip.Builder()
    }
    public func toBuilder() throws -> Voip.Builder {
        return try Voip.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Voip) throws -> Voip.Builder {
        return try Voip.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVersion {
            jsonMap["version"] = UInt(version)
        }
        if hasWhich {
            jsonMap["which"] = which.toString()
        }
        if !textStorage.isEmpty {
            var jsonArrayTextStorage:Array<Dictionary<String,Any>> = []
            for oneValueTextStorage in textStorage {
                let ecodedMessageTextStorage = try oneValueTextStorage.encode()
                jsonArrayTextStorage.append(ecodedMessageTextStorage)
            }
            jsonMap["textStorage"] = jsonArrayTextStorage
        }
        if hasFile {
            jsonMap["file"] = try file.encode()
        }
        if hasPayload {
            jsonMap["payload"] = payload.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Voip {
        return try Voip.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Voip {
        return try Voip.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVersion {
            output += "\(indent) version: \(version) \n"
        }
        if (hasWhich) {
            output += "\(indent) which: \(which.description)\n"
        }
        var textStorageElementIndex:Int = 0
        for oneElementTextStorage in textStorage {
            output += "\(indent) textStorage[\(textStorageElementIndex)] {\n"
            output += try oneElementTextStorage.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            textStorageElementIndex += 1
        }
        if hasFile {
            output += "\(indent) file {\n"
            if let outDescFile = file {
                output += try outDescFile.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasPayload {
            output += "\(indent) payload: \(payload) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasWhich {
                 hashCode = (hashCode &* 31) &+ which.hashValue
            }
            for oneElementTextStorage in textStorage {
                hashCode = (hashCode &* 31) &+ oneElementTextStorage.hashValue
            }
            if hasFile {
                if let hashValuefile = file?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefile
                }
            }
            if hasPayload {
                hashCode = (hashCode &* 31) &+ payload.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Voip"
    }
    override public func className() -> String {
        return "Voip"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Voip = Voip()
        public func getMessage() -> Voip {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var version:UInt32 {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:UInt32) -> Voip.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> Voip.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
            public var which:Voip.Which {
                get {
                    return builderResult.which
                }
                set (value) {
                    builderResult.hasWhich = true
                    builderResult.which = value
                }
            }
            public var hasWhich:Bool{
                get {
                    return builderResult.hasWhich
                }
            }
        @discardableResult
            public func setWhich(_ value:Voip.Which) -> Voip.Builder {
              self.which = value
              return self
            }
        @discardableResult
            public func clearWhich() -> Voip.Builder {
               builderResult.hasWhich = false
               builderResult.which = .text
               return self
            }
        public var textStorage:Array<Text> {
            get {
                return builderResult.textStorage
            }
            set (value) {
                builderResult.textStorage = value
            }
        }
        @discardableResult
        public func setTextStorage(_ value:Array<Text>) -> Voip.Builder {
            self.textStorage = value
            return self
        }
        @discardableResult
        public func clearTextStorage() -> Voip.Builder {
            builderResult.textStorage.removeAll(keepingCapacity: false)
            return self
        }
        public var file:File! {
            get {
                if fileBuilder_ != nil {
                    builderResult.file = fileBuilder_.getMessage()
                }
                return builderResult.file
            }
            set (value) {
                builderResult.hasFile = true
                builderResult.file = value
            }
        }
        public var hasFile:Bool {
            get {
                return builderResult.hasFile
            }
        }
        fileprivate var fileBuilder_:File.Builder! {
            didSet {
                builderResult.hasFile = true
            }
        }
        public func getFileBuilder() -> File.Builder {
            if fileBuilder_ == nil {
                fileBuilder_ = File.Builder()
                builderResult.file = fileBuilder_.getMessage()
                if file != nil {
                    try! fileBuilder_.mergeFrom(other: file)
                }
            }
            return fileBuilder_
        }
        @discardableResult
        public func setFile(_ value:File!) -> Voip.Builder {
            self.file = value
            return self
        }
        @discardableResult
        public func mergeFile(value:File) throws -> Voip.Builder {
            if builderResult.hasFile {
                builderResult.file = try File.builderWithPrototype(prototype:builderResult.file).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.file = value
            }
            builderResult.hasFile = true
            return self
        }
        @discardableResult
        public func clearFile() -> Voip.Builder {
            fileBuilder_ = nil
            builderResult.hasFile = false
            builderResult.file = nil
            return self
        }
        public var payload:Data {
            get {
                return builderResult.payload
            }
            set (value) {
                builderResult.hasPayload = true
                builderResult.payload = value
            }
        }
        public var hasPayload:Bool {
            get {
                return builderResult.hasPayload
            }
        }
        @discardableResult
        public func setPayload(_ value:Data) -> Voip.Builder {
            self.payload = value
            return self
        }
        @discardableResult
        public func clearPayload() -> Voip.Builder{
            builderResult.hasPayload = false
            builderResult.payload = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Voip.Builder {
            builderResult = Voip()
            return self
        }
        override public func clone() throws -> Voip.Builder {
            return try Voip.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Voip {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Voip {
            let returnMe:Voip = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Voip) throws -> Voip.Builder {
            if other == Voip() {
                return self
            }
            if other.hasVersion {
                version = other.version
            }
            if other.hasWhich {
                which = other.which
            }
            if !other.textStorage.isEmpty  {
                 builderResult.textStorage += other.textStorage
            }
            if (other.hasFile) {
                try mergeFile(value: other.file)
            }
            if other.hasPayload {
                payload = other.payload
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Voip.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Voip.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    version = try codedInputStream.readUInt32()

                case 16:
                    let valueIntwhich = try codedInputStream.readEnum()
                    if let enumswhich = Voip.Which(rawValue:valueIntwhich){
                        which = enumswhich
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntwhich))
                    }

                case 810:
                    let subBuilder = Text.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    textStorage.append(subBuilder.buildPartial())

                case 818:
                    let subBuilder:File.Builder = File.Builder()
                    if hasFile {
                        try subBuilder.mergeFrom(other: file)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    file = subBuilder.buildPartial()

                case 826:
                    payload = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Voip.Builder {
            let resultDecodedBuilder = Voip.Builder()
            if let jsonValueVersion = jsonMap["version"] as? UInt {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)
            } else if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)!
            }
            if let jsonValueWhich = jsonMap["which"] as? String {
                resultDecodedBuilder.which = try Voip.Which.fromString(jsonValueWhich)
            }
            if let jsonValueTextStorage = jsonMap["textStorage"] as? Array<Dictionary<String,Any>> {
                var jsonArrayTextStorage:Array<Text> = []
                for oneValueTextStorage in jsonValueTextStorage {
                    let messageFromStringTextStorage = try Text.Builder.decodeToBuilder(jsonMap:oneValueTextStorage).build()

                    jsonArrayTextStorage.append(messageFromStringTextStorage)
                }
                resultDecodedBuilder.textStorage = jsonArrayTextStorage
            }
            if let jsonValueFile = jsonMap["file"] as? Dictionary<String,Any> {
                resultDecodedBuilder.file = try File.Builder.decodeToBuilder(jsonMap:jsonValueFile).build()

            }
            if let jsonValuePayload = jsonMap["payload"] as? String {
                resultDecodedBuilder.payload = Data(base64Encoded:jsonValuePayload, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Voip.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Voip.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Text: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Text> {
        var mergedArray = Array<Text>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Text? {
        return try Text.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Text {
        return try Text.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Text {
        return try Text.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Text {
        return try Text.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "from": return self.from
        case "to": return self.to
        case "body": return self.body
        default: return nil
        }
    }
}
extension Text.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "from": return self.from
            case "to": return self.to
            case "body": return self.body
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.body = newSubscriptValue
            default: return
            }
        }
    }
}
extension File: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<File> {
        var mergedArray = Array<File>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> File? {
        return try File.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> File {
        return try File.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> File {
        return try File.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> File {
        return try File.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sequence": return self.sequence
        case "totalSize": return self.totalSize
        case "body": return self.body
        default: return nil
        }
    }
}
extension File.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sequence": return self.sequence
            case "totalSize": return self.totalSize
            case "body": return self.body
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sequence":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.sequence = newSubscriptValue
            case "totalSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.totalSize = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.body = newSubscriptValue
            default: return
            }
        }
    }
}
extension Voip: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Voip> {
        var mergedArray = Array<Voip>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Voip? {
        return try Voip.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Voip {
        return try Voip.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Voip {
        return try Voip.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Voip {
        return try Voip.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Voip {
        return try Voip.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Voip {
        return try Voip.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Voip {
        return try Voip.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "which": return self.which
        case "textStorage": return self.textStorage
        case "file": return self.file
        case "payload": return self.payload
        default: return nil
        }
    }
}
extension Voip.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "which": return self.which
            case "textStorage": return self.textStorage
            case "file": return self.file
            case "payload": return self.payload
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            case "which":
                guard let newSubscriptValue = newSubscriptValue as? Voip.Which else {
                    return
                }
                self.which = newSubscriptValue
            case "textStorage":
                guard let newSubscriptValue = newSubscriptValue as? Array<Text> else {
                    return
                }
                self.textStorage = newSubscriptValue
            case "file":
                guard let newSubscriptValue = newSubscriptValue as? File else {
                    return
                }
                self.file = newSubscriptValue
            case "payload":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.payload = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
