/// Generated by the Protocol Buffers 3.3.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.16
/// Source file "wire.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct WireRoot {
    public static let `default` = WireRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Contact : GeneratedMessage {

    public static func == (lhs: Contact, rhs: Contact) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasOnline == rhs.hasOnline) && (!lhs.hasOnline || lhs.online == rhs.online)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:String! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var online:Bool! = nil
    public fileprivate(set) var hasOnline:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeString(fieldNumber: 1, value:id)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 2, value:name)
        }
        if hasOnline {
            try codedOutputStream.writeBool(fieldNumber: 3, value:online)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeStringSize(fieldNumber: 1)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 2)
        }
        if hasOnline {
            serialize_size += online.computeBoolSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Contact.Builder {
        return Contact.classBuilder() as! Contact.Builder
    }
    public func getBuilder() -> Contact.Builder {
        return classBuilder() as! Contact.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Contact.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Contact.Builder()
    }
    public func toBuilder() throws -> Contact.Builder {
        return try Contact.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Contact) throws -> Contact.Builder {
        return try Contact.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = id
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasOnline {
            jsonMap["online"] = online
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Contact {
        return try Contact.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Contact {
        return try Contact.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasOnline {
            output += "\(indent) online: \(online) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasOnline {
                hashCode = (hashCode &* 31) &+ online.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Contact"
    }
    override public func className() -> String {
        return "Contact"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Contact = Contact()
        public func getMessage() -> Contact {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:String {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:String) -> Contact.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Contact.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> Contact.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> Contact.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var online:Bool {
            get {
                return builderResult.online
            }
            set (value) {
                builderResult.hasOnline = true
                builderResult.online = value
            }
        }
        public var hasOnline:Bool {
            get {
                return builderResult.hasOnline
            }
        }
        @discardableResult
        public func setOnline(_ value:Bool) -> Contact.Builder {
            self.online = value
            return self
        }
        @discardableResult
        public func clearOnline() -> Contact.Builder{
            builderResult.hasOnline = false
            builderResult.online = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Contact.Builder {
            builderResult = Contact()
            return self
        }
        override public func clone() throws -> Contact.Builder {
            return try Contact.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Contact {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Contact {
            let returnMe:Contact = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Contact) throws -> Contact.Builder {
            if other == Contact() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasName {
                name = other.name
            }
            if other.hasOnline {
                online = other.online
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Contact.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Contact.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    id = try codedInputStream.readString()

                case 18:
                    name = try codedInputStream.readString()

                case 24:
                    online = try codedInputStream.readBool()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Contact.Builder {
            let resultDecodedBuilder = Contact.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = jsonValueId
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueOnline = jsonMap["online"] as? Bool {
                resultDecodedBuilder.online = jsonValueOnline
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Contact.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Contact.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Store : GeneratedMessage {

    public static func == (lhs: Store, rhs: Store) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var key:Data! = nil
    public fileprivate(set) var hasKey:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasKey {
            try codedOutputStream.writeData(fieldNumber: 1, value:key)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
            serialize_size += key.computeDataSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Store.Builder {
        return Store.classBuilder() as! Store.Builder
    }
    public func getBuilder() -> Store.Builder {
        return classBuilder() as! Store.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Store.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Store.Builder()
    }
    public func toBuilder() throws -> Store.Builder {
        return try Store.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Store) throws -> Store.Builder {
        return try Store.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasKey {
            jsonMap["key"] = key.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Store {
        return try Store.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Store {
        return try Store.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasKey {
            output += "\(indent) key: \(key) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasKey {
                hashCode = (hashCode &* 31) &+ key.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Store"
    }
    override public func className() -> String {
        return "Store"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Store = Store()
        public func getMessage() -> Store {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var key:Data {
            get {
                return builderResult.key
            }
            set (value) {
                builderResult.hasKey = true
                builderResult.key = value
            }
        }
        public var hasKey:Bool {
            get {
                return builderResult.hasKey
            }
        }
        @discardableResult
        public func setKey(_ value:Data) -> Store.Builder {
            self.key = value
            return self
        }
        @discardableResult
        public func clearKey() -> Store.Builder{
            builderResult.hasKey = false
            builderResult.key = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Store.Builder {
            builderResult = Store()
            return self
        }
        override public func clone() throws -> Store.Builder {
            return try Store.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Store {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Store {
            let returnMe:Store = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Store) throws -> Store.Builder {
            if other == Store() {
                return self
            }
            if other.hasKey {
                key = other.key
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Store.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Store.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    key = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Store.Builder {
            let resultDecodedBuilder = Store.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
                resultDecodedBuilder.key = Data(base64Encoded:jsonValueKey, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Store.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Store.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Wire : GeneratedMessage {

    public static func == (lhs: Wire, rhs: Wire) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
        fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
        fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
        fieldCheck = fieldCheck && (lhs.hasWhich == rhs.hasWhich) && (!lhs.hasWhich || lhs.which == rhs.which)
        fieldCheck = fieldCheck && (lhs.hasLogin == rhs.hasLogin) && (!lhs.hasLogin || lhs.login == rhs.login)
        fieldCheck = fieldCheck && (lhs.contacts == rhs.contacts)
        fieldCheck = fieldCheck && (lhs.hasStore == rhs.hasStore) && (!lhs.hasStore || lhs.store == rhs.store)
        fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



        //Enum type declaration start 

        /// Identifies which field is filled in
        public enum Which:Int32, GeneratedEnum {
            case login = 0
            case contacts = 1
            case presence = 2
            case store = 3
            case load = 4
            case publicKey = 5
            case publicKeyResponse = 6
            case handshake = 7
            case payload = 8
            public func toString() -> String {
                switch self {
                case .login: return "LOGIN"
                case .contacts: return "CONTACTS"
                case .presence: return "PRESENCE"
                case .store: return "STORE"
                case .load: return "LOAD"
                case .publicKey: return "PUBLIC_KEY"
                case .publicKeyResponse: return "PUBLIC_KEY_RESPONSE"
                case .handshake: return "HANDSHAKE"
                case .payload: return "PAYLOAD"
                }
            }
            public static func fromString(_ str:String) throws -> Wire.Which {
                switch str {
                case "LOGIN":    return .login
                case "CONTACTS":    return .contacts
                case "PRESENCE":    return .presence
                case "STORE":    return .store
                case "LOAD":    return .load
                case "PUBLIC_KEY":    return .publicKey
                case "PUBLIC_KEY_RESPONSE":    return .publicKeyResponse
                case "HANDSHAKE":    return .handshake
                case "PAYLOAD":    return .payload
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .login: return ".login"
                case .contacts: return ".contacts"
                case .presence: return ".presence"
                case .store: return ".store"
                case .load: return ".load"
                case .publicKey: return ".publicKey"
                case .publicKeyResponse: return ".publicKeyResponse"
                case .handshake: return ".handshake"
                case .payload: return ".payload"
                }
            }
            public var hashValue:Int {
                return self.rawValue.hashValue
            }
            public static func ==(lhs:Which, rhs:Which) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 

    public fileprivate(set) var version:UInt32! = nil
    public fileprivate(set) var hasVersion:Bool = false

    public fileprivate(set) var sessionId:String! = nil
    public fileprivate(set) var hasSessionId:Bool = false

    public fileprivate(set) var from:String! = nil
    public fileprivate(set) var hasFrom:Bool = false

    public fileprivate(set) var to:String! = nil
    public fileprivate(set) var hasTo:Bool = false

    public fileprivate(set) var which:Wire.Which = Wire.Which.login
    public fileprivate(set) var hasWhich:Bool = false
    /// One of the following will be filled in
    public fileprivate(set) var login:String! = nil
    public fileprivate(set) var hasLogin:Bool = false

    public fileprivate(set) var contacts:Array<Contact>  = Array<Contact>()
    public fileprivate(set) var store:Store!
    public fileprivate(set) var hasStore:Bool = false
    public fileprivate(set) var payload:Data! = nil
    public fileprivate(set) var hasPayload:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVersion {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:version)
        }
        if hasSessionId {
            try codedOutputStream.writeString(fieldNumber: 2, value:sessionId)
        }
        if hasFrom {
            try codedOutputStream.writeString(fieldNumber: 3, value:from)
        }
        if hasTo {
            try codedOutputStream.writeString(fieldNumber: 4, value:to)
        }
        if hasWhich {
            try codedOutputStream.writeEnum(fieldNumber: 5, value:which.rawValue)
        }
        if hasLogin {
            try codedOutputStream.writeString(fieldNumber: 101, value:login)
        }
        for oneElementContacts in contacts {
              try codedOutputStream.writeMessage(fieldNumber: 102, value:oneElementContacts)
        }
        if hasStore {
            try codedOutputStream.writeMessage(fieldNumber: 104, value:store)
        }
        if hasPayload {
            try codedOutputStream.writeData(fieldNumber: 106, value:payload)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVersion {
            serialize_size += version.computeUInt32Size(fieldNumber: 1)
        }
        if hasSessionId {
            serialize_size += sessionId.computeStringSize(fieldNumber: 2)
        }
        if hasFrom {
            serialize_size += from.computeStringSize(fieldNumber: 3)
        }
        if hasTo {
            serialize_size += to.computeStringSize(fieldNumber: 4)
        }
        if (hasWhich) {
            serialize_size += which.rawValue.computeEnumSize(fieldNumber: 5)
        }
        if hasLogin {
            serialize_size += login.computeStringSize(fieldNumber: 101)
        }
        for oneElementContacts in contacts {
            serialize_size += oneElementContacts.computeMessageSize(fieldNumber: 102)
        }
        if hasStore {
            if let varSizestore = store?.computeMessageSize(fieldNumber: 104) {
                serialize_size += varSizestore
            }
        }
        if hasPayload {
            serialize_size += payload.computeDataSize(fieldNumber: 106)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Wire.Builder {
        return Wire.classBuilder() as! Wire.Builder
    }
    public func getBuilder() -> Wire.Builder {
        return classBuilder() as! Wire.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Wire.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Wire.Builder()
    }
    public func toBuilder() throws -> Wire.Builder {
        return try Wire.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Wire) throws -> Wire.Builder {
        return try Wire.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVersion {
            jsonMap["version"] = UInt(version)
        }
        if hasSessionId {
            jsonMap["sessionId"] = sessionId
        }
        if hasFrom {
            jsonMap["from"] = from
        }
        if hasTo {
            jsonMap["to"] = to
        }
        if hasWhich {
            jsonMap["which"] = which.toString()
        }
        if hasLogin {
            jsonMap["login"] = login
        }
        if !contacts.isEmpty {
            var jsonArrayContacts:Array<Dictionary<String,Any>> = []
            for oneValueContacts in contacts {
                let ecodedMessageContacts = try oneValueContacts.encode()
                jsonArrayContacts.append(ecodedMessageContacts)
            }
            jsonMap["contacts"] = jsonArrayContacts
        }
        if hasStore {
            jsonMap["store"] = try store.encode()
        }
        if hasPayload {
            jsonMap["payload"] = payload.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Wire {
        return try Wire.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Wire {
        return try Wire.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVersion {
            output += "\(indent) version: \(version) \n"
        }
        if hasSessionId {
            output += "\(indent) sessionId: \(sessionId) \n"
        }
        if hasFrom {
            output += "\(indent) from: \(from) \n"
        }
        if hasTo {
            output += "\(indent) to: \(to) \n"
        }
        if (hasWhich) {
            output += "\(indent) which: \(which.description)\n"
        }
        if hasLogin {
            output += "\(indent) login: \(login) \n"
        }
        var contactsElementIndex:Int = 0
        for oneElementContacts in contacts {
            output += "\(indent) contacts[\(contactsElementIndex)] {\n"
            output += try oneElementContacts.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            contactsElementIndex += 1
        }
        if hasStore {
            output += "\(indent) store {\n"
            if let outDescStore = store {
                output += try outDescStore.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasPayload {
            output += "\(indent) payload: \(payload) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasSessionId {
                hashCode = (hashCode &* 31) &+ sessionId.hashValue
            }
            if hasFrom {
                hashCode = (hashCode &* 31) &+ from.hashValue
            }
            if hasTo {
                hashCode = (hashCode &* 31) &+ to.hashValue
            }
            if hasWhich {
                 hashCode = (hashCode &* 31) &+ which.hashValue
            }
            if hasLogin {
                hashCode = (hashCode &* 31) &+ login.hashValue
            }
            for oneElementContacts in contacts {
                hashCode = (hashCode &* 31) &+ oneElementContacts.hashValue
            }
            if hasStore {
                if let hashValuestore = store?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuestore
                }
            }
            if hasPayload {
                hashCode = (hashCode &* 31) &+ payload.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Wire"
    }
    override public func className() -> String {
        return "Wire"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Wire = Wire()
        public func getMessage() -> Wire {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var version:UInt32 {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:UInt32) -> Wire.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> Wire.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        public var sessionId:String {
            get {
                return builderResult.sessionId
            }
            set (value) {
                builderResult.hasSessionId = true
                builderResult.sessionId = value
            }
        }
        public var hasSessionId:Bool {
            get {
                return builderResult.hasSessionId
            }
        }
        @discardableResult
        public func setSessionId(_ value:String) -> Wire.Builder {
            self.sessionId = value
            return self
        }
        @discardableResult
        public func clearSessionId() -> Wire.Builder{
            builderResult.hasSessionId = false
            builderResult.sessionId = nil
            return self
        }
        public var from:String {
            get {
                return builderResult.from
            }
            set (value) {
                builderResult.hasFrom = true
                builderResult.from = value
            }
        }
        public var hasFrom:Bool {
            get {
                return builderResult.hasFrom
            }
        }
        @discardableResult
        public func setFrom(_ value:String) -> Wire.Builder {
            self.from = value
            return self
        }
        @discardableResult
        public func clearFrom() -> Wire.Builder{
            builderResult.hasFrom = false
            builderResult.from = nil
            return self
        }
        public var to:String {
            get {
                return builderResult.to
            }
            set (value) {
                builderResult.hasTo = true
                builderResult.to = value
            }
        }
        public var hasTo:Bool {
            get {
                return builderResult.hasTo
            }
        }
        @discardableResult
        public func setTo(_ value:String) -> Wire.Builder {
            self.to = value
            return self
        }
        @discardableResult
        public func clearTo() -> Wire.Builder{
            builderResult.hasTo = false
            builderResult.to = nil
            return self
        }
            public var which:Wire.Which {
                get {
                    return builderResult.which
                }
                set (value) {
                    builderResult.hasWhich = true
                    builderResult.which = value
                }
            }
            public var hasWhich:Bool{
                get {
                    return builderResult.hasWhich
                }
            }
        @discardableResult
            public func setWhich(_ value:Wire.Which) -> Wire.Builder {
              self.which = value
              return self
            }
        @discardableResult
            public func clearWhich() -> Wire.Builder {
               builderResult.hasWhich = false
               builderResult.which = .login
               return self
            }
        /// One of the following will be filled in
        public var login:String {
            get {
                return builderResult.login
            }
            set (value) {
                builderResult.hasLogin = true
                builderResult.login = value
            }
        }
        public var hasLogin:Bool {
            get {
                return builderResult.hasLogin
            }
        }
        @discardableResult
        public func setLogin(_ value:String) -> Wire.Builder {
            self.login = value
            return self
        }
        @discardableResult
        public func clearLogin() -> Wire.Builder{
            builderResult.hasLogin = false
            builderResult.login = nil
            return self
        }
        /// for roster, presence, and invite
        public var contacts:Array<Contact> {
            get {
                return builderResult.contacts
            }
            set (value) {
                builderResult.contacts = value
            }
        }
        @discardableResult
        public func setContacts(_ value:Array<Contact>) -> Wire.Builder {
            self.contacts = value
            return self
        }
        @discardableResult
        public func clearContacts() -> Wire.Builder {
            builderResult.contacts.removeAll(keepingCapacity: false)
            return self
        }
        public var store:Store! {
            get {
                if storeBuilder_ != nil {
                    builderResult.store = storeBuilder_.getMessage()
                }
                return builderResult.store
            }
            set (value) {
                builderResult.hasStore = true
                builderResult.store = value
            }
        }
        public var hasStore:Bool {
            get {
                return builderResult.hasStore
            }
        }
        fileprivate var storeBuilder_:Store.Builder! {
            didSet {
                builderResult.hasStore = true
            }
        }
        public func getStoreBuilder() -> Store.Builder {
            if storeBuilder_ == nil {
                storeBuilder_ = Store.Builder()
                builderResult.store = storeBuilder_.getMessage()
                if store != nil {
                    try! storeBuilder_.mergeFrom(other: store)
                }
            }
            return storeBuilder_
        }
        @discardableResult
        public func setStore(_ value:Store!) -> Wire.Builder {
            self.store = value
            return self
        }
        @discardableResult
        public func mergeStore(value:Store) throws -> Wire.Builder {
            if builderResult.hasStore {
                builderResult.store = try Store.builderWithPrototype(prototype:builderResult.store).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.store = value
            }
            builderResult.hasStore = true
            return self
        }
        @discardableResult
        public func clearStore() -> Wire.Builder {
            storeBuilder_ = nil
            builderResult.hasStore = false
            builderResult.store = nil
            return self
        }
        public var payload:Data {
            get {
                return builderResult.payload
            }
            set (value) {
                builderResult.hasPayload = true
                builderResult.payload = value
            }
        }
        public var hasPayload:Bool {
            get {
                return builderResult.hasPayload
            }
        }
        @discardableResult
        public func setPayload(_ value:Data) -> Wire.Builder {
            self.payload = value
            return self
        }
        @discardableResult
        public func clearPayload() -> Wire.Builder{
            builderResult.hasPayload = false
            builderResult.payload = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Wire.Builder {
            builderResult = Wire()
            return self
        }
        override public func clone() throws -> Wire.Builder {
            return try Wire.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Wire {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Wire {
            let returnMe:Wire = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Wire) throws -> Wire.Builder {
            if other == Wire() {
                return self
            }
            if other.hasVersion {
                version = other.version
            }
            if other.hasSessionId {
                sessionId = other.sessionId
            }
            if other.hasFrom {
                from = other.from
            }
            if other.hasTo {
                to = other.to
            }
            if other.hasWhich {
                which = other.which
            }
            if other.hasLogin {
                login = other.login
            }
            if !other.contacts.isEmpty  {
                 builderResult.contacts += other.contacts
            }
            if (other.hasStore) {
                try mergeStore(value: other.store)
            }
            if other.hasPayload {
                payload = other.payload
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Wire.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Wire.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    version = try codedInputStream.readUInt32()

                case 18:
                    sessionId = try codedInputStream.readString()

                case 26:
                    from = try codedInputStream.readString()

                case 34:
                    to = try codedInputStream.readString()

                case 40:
                    let valueIntwhich = try codedInputStream.readEnum()
                    if let enumswhich = Wire.Which(rawValue:valueIntwhich){
                        which = enumswhich
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntwhich))
                    }

                case 810:
                    login = try codedInputStream.readString()

                case 818:
                    let subBuilder = Contact.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    contacts.append(subBuilder.buildPartial())

                case 834:
                    let subBuilder:Store.Builder = Store.Builder()
                    if hasStore {
                        try subBuilder.mergeFrom(other: store)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    store = subBuilder.buildPartial()

                case 850:
                    payload = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Wire.Builder {
            let resultDecodedBuilder = Wire.Builder()
            if let jsonValueVersion = jsonMap["version"] as? UInt {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)
            } else if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)!
            }
            if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                resultDecodedBuilder.sessionId = jsonValueSessionId
            }
            if let jsonValueFrom = jsonMap["from"] as? String {
                resultDecodedBuilder.from = jsonValueFrom
            }
            if let jsonValueTo = jsonMap["to"] as? String {
                resultDecodedBuilder.to = jsonValueTo
            }
            if let jsonValueWhich = jsonMap["which"] as? String {
                resultDecodedBuilder.which = try Wire.Which.fromString(jsonValueWhich)
            }
            if let jsonValueLogin = jsonMap["login"] as? String {
                resultDecodedBuilder.login = jsonValueLogin
            }
            if let jsonValueContacts = jsonMap["contacts"] as? Array<Dictionary<String,Any>> {
                var jsonArrayContacts:Array<Contact> = []
                for oneValueContacts in jsonValueContacts {
                    let messageFromStringContacts = try Contact.Builder.decodeToBuilder(jsonMap:oneValueContacts).build()

                    jsonArrayContacts.append(messageFromStringContacts)
                }
                resultDecodedBuilder.contacts = jsonArrayContacts
            }
            if let jsonValueStore = jsonMap["store"] as? Dictionary<String,Any> {
                resultDecodedBuilder.store = try Store.Builder.decodeToBuilder(jsonMap:jsonValueStore).build()

            }
            if let jsonValuePayload = jsonMap["payload"] as? String {
                resultDecodedBuilder.payload = Data(base64Encoded:jsonValuePayload, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Wire.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Wire.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Contact: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Contact> {
        var mergedArray = Array<Contact>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Contact? {
        return try Contact.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Contact {
        return try Contact.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Contact {
        return try Contact.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Contact {
        return try Contact.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        case "online": return self.online
        default: return nil
        }
    }
}
extension Contact.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            case "online": return self.online
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "online":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.online = newSubscriptValue
            default: return
            }
        }
    }
}
extension Store: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Store> {
        var mergedArray = Array<Store>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Store? {
        return try Store.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Store {
        return try Store.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Store {
        return try Store.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Store {
        return try Store.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Store {
        return try Store.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Store {
        return try Store.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Store {
        return try Store.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        default: return nil
        }
    }
}
extension Store.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.key = newSubscriptValue
            default: return
            }
        }
    }
}
extension Wire: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Wire> {
        var mergedArray = Array<Wire>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Wire? {
        return try Wire.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Wire {
        return try Wire.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Wire {
        return try Wire.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Wire {
        return try Wire.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Wire {
        return try Wire.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Wire {
        return try Wire.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Wire {
        return try Wire.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "sessionId": return self.sessionId
        case "from": return self.from
        case "to": return self.to
        case "which": return self.which
        case "login": return self.login
        case "contacts": return self.contacts
        case "store": return self.store
        case "payload": return self.payload
        default: return nil
        }
    }
}
extension Wire.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "sessionId": return self.sessionId
            case "from": return self.from
            case "to": return self.to
            case "which": return self.which
            case "login": return self.login
            case "contacts": return self.contacts
            case "store": return self.store
            case "payload": return self.payload
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            case "which":
                guard let newSubscriptValue = newSubscriptValue as? Wire.Which else {
                    return
                }
                self.which = newSubscriptValue
            case "login":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.login = newSubscriptValue
            case "contacts":
                guard let newSubscriptValue = newSubscriptValue as? Array<Contact> else {
                    return
                }
                self.contacts = newSubscriptValue
            case "store":
                guard let newSubscriptValue = newSubscriptValue as? Store else {
                    return
                }
                self.store = newSubscriptValue
            case "payload":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.payload = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
