// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: voip.proto

#ifndef PROTOBUF_voip_2eproto__INCLUDED
#define PROTOBUF_voip_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class AVQuality;
class AVQualityDefaultTypeInternal;
extern AVQualityDefaultTypeInternal _AVQuality_default_instance_;
class AVSession;
class AVSessionDefaultTypeInternal;
extern AVSessionDefaultTypeInternal _AVSession_default_instance_;
class AudioSample;
class AudioSampleDefaultTypeInternal;
extern AudioSampleDefaultTypeInternal _AudioSample_default_instance_;
class Av;
class AvDefaultTypeInternal;
extern AvDefaultTypeInternal _Av_default_instance_;
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class File;
class FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class FormatDescription;
class FormatDescriptionDefaultTypeInternal;
extern FormatDescriptionDefaultTypeInternal _FormatDescription_default_instance_;
class FormatDescription_ExtensionsEntry;
class FormatDescription_ExtensionsEntryDefaultTypeInternal;
extern FormatDescription_ExtensionsEntryDefaultTypeInternal _FormatDescription_ExtensionsEntry_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Image_AttachmentsEntry;
class Image_AttachmentsEntryDefaultTypeInternal;
extern Image_AttachmentsEntryDefaultTypeInternal _Image_AttachmentsEntry_default_instance_;
class Text;
class TextDefaultTypeInternal;
extern TextDefaultTypeInternal _Text_default_instance_;
class Time;
class TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class VideoSample;
class VideoSampleDefaultTypeInternal;
extern VideoSampleDefaultTypeInternal _VideoSample_default_instance_;
class Voip;
class VoipDefaultTypeInternal;
extern VoipDefaultTypeInternal _Voip_default_instance_;

namespace protobuf_voip_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_voip_2eproto

enum Voip_Which {
  Voip_Which_TEXT = 0,
  Voip_Which_FILE = 1,
  Voip_Which_AV = 2,
  Voip_Which_AudioSession = 3,
  Voip_Which_VideoSession = 4,
  Voip_Which_CALL_PROPOSAL = 5,
  Voip_Which_CALL_CANCEL = 6,
  Voip_Which_CALL_ACCEPT = 7,
  Voip_Which_CALL_DECLINE = 8,
  Voip_Which_CALL_START_OUTGOING = 9,
  Voip_Which_CALL_START_INCOMING = 10,
  Voip_Which_CALL_QUALITY = 11,
  Voip_Which_CALL_STOP = 12,
  Voip_Which_Voip_Which_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Voip_Which_Voip_Which_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Voip_Which_IsValid(int value);
const Voip_Which Voip_Which_Which_MIN = Voip_Which_TEXT;
const Voip_Which Voip_Which_Which_MAX = Voip_Which_CALL_STOP;
const int Voip_Which_Which_ARRAYSIZE = Voip_Which_Which_MAX + 1;

const ::google::protobuf::EnumDescriptor* Voip_Which_descriptor();
inline const ::std::string& Voip_Which_Name(Voip_Which value) {
  return ::google::protobuf::internal::NameOfEnum(
    Voip_Which_descriptor(), value);
}
inline bool Voip_Which_Parse(
    const ::std::string& name, Voip_Which* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Voip_Which>(
    Voip_Which_descriptor(), name, value);
}
// ===================================================================

class Text : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Text) */ {
 public:
  Text();
  virtual ~Text();

  Text(const Text& from);

  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Text(Text&& from) noexcept
    : Text() {
    *this = ::std::move(from);
  }

  inline Text& operator=(Text&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Text& default_instance();

  static inline const Text* internal_default_instance() {
    return reinterpret_cast<const Text*>(
               &_Text_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Text* other);
  friend void swap(Text& a, Text& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Text* New() const PROTOBUF_FINAL { return New(NULL); }

  Text* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Text& from);
  void MergeFrom(const Text& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Text* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // bytes body = 3;
  void clear_body();
  static const int kBodyFieldNumber = 3;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:Text)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(File* other);
  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline File* New() const PROTOBUF_FINAL { return New(NULL); }

  File* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes body = 3;
  void clear_body();
  static const int kBodyFieldNumber = 3;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // uint64 sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  ::google::protobuf::uint64 sequence() const;
  void set_sequence(::google::protobuf::uint64 value);

  // uint64 totalSize = 2;
  void clear_totalsize();
  static const int kTotalSizeFieldNumber = 2;
  ::google::protobuf::uint64 totalsize() const;
  void set_totalsize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  ::google::protobuf::uint64 sequence_;
  ::google::protobuf::uint64 totalsize_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Call) */ {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Call* other);
  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const PROTOBUF_FINAL { return New(NULL); }

  Call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // string from = 3;
  void clear_from();
  static const int kFromFieldNumber = 3;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // bool audio = 4;
  void clear_audio();
  static const int kAudioFieldNumber = 4;
  bool audio() const;
  void set_audio(bool value);

  // bool video = 5;
  void clear_video();
  static const int kVideoFieldNumber = 5;
  bool video() const;
  void set_video(bool value);

  // @@protoc_insertion_point(class_scope:Call)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  bool audio_;
  bool video_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(Time&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Time* other);
  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Time* New() const PROTOBUF_FINAL { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // int32 scale = 2;
  void clear_scale();
  static const int kScaleFieldNumber = 2;
  ::google::protobuf::int32 scale() const;
  void set_scale(::google::protobuf::int32 value);

  // uint32 flags = 3;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // int64 epoch = 4;
  void clear_epoch();
  static const int kEpochFieldNumber = 4;
  ::google::protobuf::int64 epoch() const;
  void set_epoch(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Time)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 value_;
  ::google::protobuf::int32 scale_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::int64 epoch_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Timestamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const PROTOBUF_FINAL { return New(NULL); }

  Timestamp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Time duration = 1;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  const ::Time& duration() const;
  ::Time* mutable_duration();
  ::Time* release_duration();
  void set_allocated_duration(::Time* duration);

  // .Time presentation = 2;
  bool has_presentation() const;
  void clear_presentation();
  static const int kPresentationFieldNumber = 2;
  const ::Time& presentation() const;
  ::Time* mutable_presentation();
  ::Time* release_presentation();
  void set_allocated_presentation(::Time* presentation);

  // @@protoc_insertion_point(class_scope:Timestamp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Time* duration_;
  ::Time* presentation_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const PROTOBUF_FINAL { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> attachments = 4;
  int attachments_size() const;
  void clear_attachments();
  static const int kAttachmentsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      attachments() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_attachments();

  // bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int64 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int64 width() const;
  void set_width(::google::protobuf::int64 value);

  // int64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // uint32 format = 3;
  void clear_format();
  static const int kFormatFieldNumber = 3;
  ::google::protobuf::uint32 format() const;
  void set_format(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Image)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class Image_AttachmentsEntry : public ::google::protobuf::internal::MapEntry<Image_AttachmentsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<Image_AttachmentsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > SuperType;
    Image_AttachmentsEntry();
    Image_AttachmentsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const Image_AttachmentsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_Image_AttachmentsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      Image_AttachmentsEntry,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > attachments_;
  private:
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 width_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::uint32 format_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class FormatDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FormatDescription) */ {
 public:
  FormatDescription();
  virtual ~FormatDescription();

  FormatDescription(const FormatDescription& from);

  inline FormatDescription& operator=(const FormatDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FormatDescription(FormatDescription&& from) noexcept
    : FormatDescription() {
    *this = ::std::move(from);
  }

  inline FormatDescription& operator=(FormatDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatDescription& default_instance();

  static inline const FormatDescription* internal_default_instance() {
    return reinterpret_cast<const FormatDescription*>(
               &_FormatDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(FormatDescription* other);
  friend void swap(FormatDescription& a, FormatDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FormatDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  FormatDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FormatDescription& from);
  void MergeFrom(const FormatDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FormatDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> extensions = 3;
  int extensions_size() const;
  void clear_extensions();
  static const int kExtensionsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      extensions() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_extensions();

  // uint32 mediaType = 1;
  void clear_mediatype();
  static const int kMediaTypeFieldNumber = 1;
  ::google::protobuf::uint32 mediatype() const;
  void set_mediatype(::google::protobuf::uint32 value);

  // uint32 mediaSubtype = 2;
  void clear_mediasubtype();
  static const int kMediaSubtypeFieldNumber = 2;
  ::google::protobuf::uint32 mediasubtype() const;
  void set_mediasubtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:FormatDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class FormatDescription_ExtensionsEntry : public ::google::protobuf::internal::MapEntry<FormatDescription_ExtensionsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<FormatDescription_ExtensionsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > SuperType;
    FormatDescription_ExtensionsEntry();
    FormatDescription_ExtensionsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const FormatDescription_ExtensionsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_FormatDescription_ExtensionsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      FormatDescription_ExtensionsEntry,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > extensions_;
  private:
  ::google::protobuf::uint32 mediatype_;
  ::google::protobuf::uint32 mediasubtype_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VideoSample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VideoSample) */ {
 public:
  VideoSample();
  virtual ~VideoSample();

  VideoSample(const VideoSample& from);

  inline VideoSample& operator=(const VideoSample& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VideoSample(VideoSample&& from) noexcept
    : VideoSample() {
    *this = ::std::move(from);
  }

  inline VideoSample& operator=(VideoSample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoSample& default_instance();

  static inline const VideoSample* internal_default_instance() {
    return reinterpret_cast<const VideoSample*>(
               &_VideoSample_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(VideoSample* other);
  friend void swap(VideoSample& a, VideoSample& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VideoSample* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoSample* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VideoSample& from);
  void MergeFrom(const VideoSample& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VideoSample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Image image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::Image& image() const;
  ::Image* mutable_image();
  ::Image* release_image();
  void set_allocated_image(::Image* image);

  // @@protoc_insertion_point(class_scope:VideoSample)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Image* image_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioSample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AudioSample) */ {
 public:
  AudioSample();
  virtual ~AudioSample();

  AudioSample(const AudioSample& from);

  inline AudioSample& operator=(const AudioSample& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AudioSample(AudioSample&& from) noexcept
    : AudioSample() {
    *this = ::std::move(from);
  }

  inline AudioSample& operator=(AudioSample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioSample& default_instance();

  static inline const AudioSample* internal_default_instance() {
    return reinterpret_cast<const AudioSample*>(
               &_AudioSample_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(AudioSample* other);
  friend void swap(AudioSample& a, AudioSample& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AudioSample* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioSample* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AudioSample& from);
  void MergeFrom(const AudioSample& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AudioSample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Image image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::Image& image() const;
  ::Image* mutable_image();
  ::Image* release_image();
  void set_allocated_image(::Image* image);

  // @@protoc_insertion_point(class_scope:AudioSample)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Image* image_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Av : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Av) */ {
 public:
  Av();
  virtual ~Av();

  Av(const Av& from);

  inline Av& operator=(const Av& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Av(Av&& from) noexcept
    : Av() {
    *this = ::std::move(from);
  }

  inline Av& operator=(Av&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Av& default_instance();

  static inline const Av* internal_default_instance() {
    return reinterpret_cast<const Av*>(
               &_Av_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Av* other);
  friend void swap(Av& a, Av& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Av* New() const PROTOBUF_FINAL { return New(NULL); }

  Av* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Av& from);
  void MergeFrom(const Av& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Av* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .VideoSample video = 1;
  bool has_video() const;
  void clear_video();
  static const int kVideoFieldNumber = 1;
  const ::VideoSample& video() const;
  ::VideoSample* mutable_video();
  ::VideoSample* release_video();
  void set_allocated_video(::VideoSample* video);

  // .AudioSample audio = 2;
  bool has_audio() const;
  void clear_audio();
  static const int kAudioFieldNumber = 2;
  const ::AudioSample& audio() const;
  ::AudioSample* mutable_audio();
  ::AudioSample* release_audio();
  void set_allocated_audio(::AudioSample* audio);

  // @@protoc_insertion_point(class_scope:Av)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::VideoSample* video_;
  ::AudioSample* audio_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AVSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AVSession) */ {
 public:
  AVSession();
  virtual ~AVSession();

  AVSession(const AVSession& from);

  inline AVSession& operator=(const AVSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AVSession(AVSession&& from) noexcept
    : AVSession() {
    *this = ::std::move(from);
  }

  inline AVSession& operator=(AVSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AVSession& default_instance();

  static inline const AVSession* internal_default_instance() {
    return reinterpret_cast<const AVSession*>(
               &_AVSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(AVSession* other);
  friend void swap(AVSession& a, AVSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AVSession* New() const PROTOBUF_FINAL { return New(NULL); }

  AVSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AVSession& from);
  void MergeFrom(const AVSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AVSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sid = 1;
  void clear_sid();
  static const int kSidFieldNumber = 1;
  const ::std::string& sid() const;
  void set_sid(const ::std::string& value);
  #if LANG_CXX11
  void set_sid(::std::string&& value);
  #endif
  void set_sid(const char* value);
  void set_sid(const char* value, size_t size);
  ::std::string* mutable_sid();
  ::std::string* release_sid();
  void set_allocated_sid(::std::string* sid);

  // string gid = 2;
  void clear_gid();
  static const int kGidFieldNumber = 2;
  const ::std::string& gid() const;
  void set_gid(const ::std::string& value);
  #if LANG_CXX11
  void set_gid(::std::string&& value);
  #endif
  void set_gid(const char* value);
  void set_gid(const char* value, size_t size);
  ::std::string* mutable_gid();
  ::std::string* release_gid();
  void set_allocated_gid(::std::string* gid);

  // bytes data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // bool active = 3;
  void clear_active();
  static const int kActiveFieldNumber = 3;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:AVSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sid_;
  ::google::protobuf::internal::ArenaStringPtr gid_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  bool active_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AVQuality : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AVQuality) */ {
 public:
  AVQuality();
  virtual ~AVQuality();

  AVQuality(const AVQuality& from);

  inline AVQuality& operator=(const AVQuality& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AVQuality(AVQuality&& from) noexcept
    : AVQuality() {
    *this = ::std::move(from);
  }

  inline AVQuality& operator=(AVQuality&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AVQuality& default_instance();

  static inline const AVQuality* internal_default_instance() {
    return reinterpret_cast<const AVQuality*>(
               &_AVQuality_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(AVQuality* other);
  friend void swap(AVQuality& a, AVQuality& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AVQuality* New() const PROTOBUF_FINAL { return New(NULL); }

  AVQuality* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AVQuality& from);
  void MergeFrom(const AVQuality& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AVQuality* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 diff = 1;
  void clear_diff();
  static const int kDiffFieldNumber = 1;
  ::google::protobuf::int32 diff() const;
  void set_diff(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AVQuality)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 diff_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Voip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Voip) */ {
 public:
  Voip();
  virtual ~Voip();

  Voip(const Voip& from);

  inline Voip& operator=(const Voip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Voip(Voip&& from) noexcept
    : Voip() {
    *this = ::std::move(from);
  }

  inline Voip& operator=(Voip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Voip& default_instance();

  static inline const Voip* internal_default_instance() {
    return reinterpret_cast<const Voip*>(
               &_Voip_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Voip* other);
  friend void swap(Voip& a, Voip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Voip* New() const PROTOBUF_FINAL { return New(NULL); }

  Voip* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Voip& from);
  void MergeFrom(const Voip& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Voip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Voip_Which Which;
  static const Which TEXT =
    Voip_Which_TEXT;
  static const Which FILE =
    Voip_Which_FILE;
  static const Which AV =
    Voip_Which_AV;
  static const Which AudioSession =
    Voip_Which_AudioSession;
  static const Which VideoSession =
    Voip_Which_VideoSession;
  static const Which CALL_PROPOSAL =
    Voip_Which_CALL_PROPOSAL;
  static const Which CALL_CANCEL =
    Voip_Which_CALL_CANCEL;
  static const Which CALL_ACCEPT =
    Voip_Which_CALL_ACCEPT;
  static const Which CALL_DECLINE =
    Voip_Which_CALL_DECLINE;
  static const Which CALL_START_OUTGOING =
    Voip_Which_CALL_START_OUTGOING;
  static const Which CALL_START_INCOMING =
    Voip_Which_CALL_START_INCOMING;
  static const Which CALL_QUALITY =
    Voip_Which_CALL_QUALITY;
  static const Which CALL_STOP =
    Voip_Which_CALL_STOP;
  static inline bool Which_IsValid(int value) {
    return Voip_Which_IsValid(value);
  }
  static const Which Which_MIN =
    Voip_Which_Which_MIN;
  static const Which Which_MAX =
    Voip_Which_Which_MAX;
  static const int Which_ARRAYSIZE =
    Voip_Which_Which_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Which_descriptor() {
    return Voip_Which_descriptor();
  }
  static inline const ::std::string& Which_Name(Which value) {
    return Voip_Which_Name(value);
  }
  static inline bool Which_Parse(const ::std::string& name,
      Which* value) {
    return Voip_Which_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .Text textStorage = 101;
  int textstorage_size() const;
  void clear_textstorage();
  static const int kTextStorageFieldNumber = 101;
  const ::Text& textstorage(int index) const;
  ::Text* mutable_textstorage(int index);
  ::Text* add_textstorage();
  ::google::protobuf::RepeatedPtrField< ::Text >*
      mutable_textstorage();
  const ::google::protobuf::RepeatedPtrField< ::Text >&
      textstorage() const;

  // bytes payload = 103;
  void clear_payload();
  static const int kPayloadFieldNumber = 103;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // .AVQuality avQuality = 18;
  bool has_avquality() const;
  void clear_avquality();
  static const int kAvQualityFieldNumber = 18;
  const ::AVQuality& avquality() const;
  ::AVQuality* mutable_avquality();
  ::AVQuality* release_avquality();
  void set_allocated_avquality(::AVQuality* avquality);

  // .File file = 102;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 102;
  const ::File& file() const;
  ::File* mutable_file();
  ::File* release_file();
  void set_allocated_file(::File* file);

  // .Call call = 104;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 104;
  const ::Call& call() const;
  ::Call* mutable_call();
  ::Call* release_call();
  void set_allocated_call(::Call* call);

  // .Av av = 105;
  bool has_av() const;
  void clear_av();
  static const int kAvFieldNumber = 105;
  const ::Av& av() const;
  ::Av* mutable_av();
  ::Av* release_av();
  void set_allocated_av(::Av* av);

  // .AVSession audioSession = 106;
  bool has_audiosession() const;
  void clear_audiosession();
  static const int kAudioSessionFieldNumber = 106;
  const ::AVSession& audiosession() const;
  ::AVSession* mutable_audiosession();
  ::AVSession* release_audiosession();
  void set_allocated_audiosession(::AVSession* audiosession);

  // .AVSession videoSession = 107;
  bool has_videosession() const;
  void clear_videosession();
  static const int kVideoSessionFieldNumber = 107;
  const ::AVSession& videosession() const;
  ::AVSession* mutable_videosession();
  ::AVSession* release_videosession();
  void set_allocated_videosession(::AVSession* videosession);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // .Voip.Which which = 12;
  void clear_which();
  static const int kWhichFieldNumber = 12;
  ::Voip_Which which() const;
  void set_which(::Voip_Which value);

  // @@protoc_insertion_point(class_scope:Voip)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Text > textstorage_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::AVQuality* avquality_;
  ::File* file_;
  ::Call* call_;
  ::Av* av_;
  ::AVSession* audiosession_;
  ::AVSession* videosession_;
  ::google::protobuf::uint32 version_;
  int which_;
  mutable int _cached_size_;
  friend struct protobuf_voip_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Text

// string from = 1;
inline void Text::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Text::from() const {
  // @@protoc_insertion_point(field_get:Text.from)
  return from_.GetNoArena();
}
inline void Text::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Text.from)
}
#if LANG_CXX11
inline void Text::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Text.from)
}
#endif
inline void Text::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Text.from)
}
inline void Text::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Text.from)
}
inline ::std::string* Text::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:Text.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Text::release_from() {
  // @@protoc_insertion_point(field_release:Text.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Text::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:Text.from)
}

// string to = 2;
inline void Text::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Text::to() const {
  // @@protoc_insertion_point(field_get:Text.to)
  return to_.GetNoArena();
}
inline void Text::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Text.to)
}
#if LANG_CXX11
inline void Text::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Text.to)
}
#endif
inline void Text::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Text.to)
}
inline void Text::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Text.to)
}
inline ::std::string* Text::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:Text.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Text::release_to() {
  // @@protoc_insertion_point(field_release:Text.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Text::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:Text.to)
}

// bytes body = 3;
inline void Text::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Text::body() const {
  // @@protoc_insertion_point(field_get:Text.body)
  return body_.GetNoArena();
}
inline void Text::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Text.body)
}
#if LANG_CXX11
inline void Text::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Text.body)
}
#endif
inline void Text::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Text.body)
}
inline void Text::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Text.body)
}
inline ::std::string* Text::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:Text.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Text::release_body() {
  // @@protoc_insertion_point(field_release:Text.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Text::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:Text.body)
}

// -------------------------------------------------------------------

// File

// uint64 sequence = 1;
inline void File::clear_sequence() {
  sequence_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 File::sequence() const {
  // @@protoc_insertion_point(field_get:File.sequence)
  return sequence_;
}
inline void File::set_sequence(::google::protobuf::uint64 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:File.sequence)
}

// uint64 totalSize = 2;
inline void File::clear_totalsize() {
  totalsize_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 File::totalsize() const {
  // @@protoc_insertion_point(field_get:File.totalSize)
  return totalsize_;
}
inline void File::set_totalsize(::google::protobuf::uint64 value) {
  
  totalsize_ = value;
  // @@protoc_insertion_point(field_set:File.totalSize)
}

// bytes body = 3;
inline void File::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::body() const {
  // @@protoc_insertion_point(field_get:File.body)
  return body_.GetNoArena();
}
inline void File::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:File.body)
}
#if LANG_CXX11
inline void File::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:File.body)
}
#endif
inline void File::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:File.body)
}
inline void File::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:File.body)
}
inline ::std::string* File::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:File.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_body() {
  // @@protoc_insertion_point(field_release:File.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:File.body)
}

// -------------------------------------------------------------------

// Call

// string key = 1;
inline void Call::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Call::key() const {
  // @@protoc_insertion_point(field_get:Call.key)
  return key_.GetNoArena();
}
inline void Call::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Call.key)
}
#if LANG_CXX11
inline void Call::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Call.key)
}
#endif
inline void Call::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Call.key)
}
inline void Call::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Call.key)
}
inline ::std::string* Call::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:Call.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Call::release_key() {
  // @@protoc_insertion_point(field_release:Call.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Call::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Call.key)
}

// string to = 2;
inline void Call::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Call::to() const {
  // @@protoc_insertion_point(field_get:Call.to)
  return to_.GetNoArena();
}
inline void Call::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Call.to)
}
#if LANG_CXX11
inline void Call::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Call.to)
}
#endif
inline void Call::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Call.to)
}
inline void Call::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Call.to)
}
inline ::std::string* Call::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:Call.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Call::release_to() {
  // @@protoc_insertion_point(field_release:Call.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Call::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:Call.to)
}

// string from = 3;
inline void Call::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Call::from() const {
  // @@protoc_insertion_point(field_get:Call.from)
  return from_.GetNoArena();
}
inline void Call::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Call.from)
}
#if LANG_CXX11
inline void Call::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Call.from)
}
#endif
inline void Call::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Call.from)
}
inline void Call::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Call.from)
}
inline ::std::string* Call::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:Call.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Call::release_from() {
  // @@protoc_insertion_point(field_release:Call.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Call::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:Call.from)
}

// bool audio = 4;
inline void Call::clear_audio() {
  audio_ = false;
}
inline bool Call::audio() const {
  // @@protoc_insertion_point(field_get:Call.audio)
  return audio_;
}
inline void Call::set_audio(bool value) {
  
  audio_ = value;
  // @@protoc_insertion_point(field_set:Call.audio)
}

// bool video = 5;
inline void Call::clear_video() {
  video_ = false;
}
inline bool Call::video() const {
  // @@protoc_insertion_point(field_get:Call.video)
  return video_;
}
inline void Call::set_video(bool value) {
  
  video_ = value;
  // @@protoc_insertion_point(field_set:Call.video)
}

// -------------------------------------------------------------------

// Time

// int64 value = 1;
inline void Time::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Time::value() const {
  // @@protoc_insertion_point(field_get:Time.value)
  return value_;
}
inline void Time::set_value(::google::protobuf::int64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Time.value)
}

// int32 scale = 2;
inline void Time::clear_scale() {
  scale_ = 0;
}
inline ::google::protobuf::int32 Time::scale() const {
  // @@protoc_insertion_point(field_get:Time.scale)
  return scale_;
}
inline void Time::set_scale(::google::protobuf::int32 value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:Time.scale)
}

// uint32 flags = 3;
inline void Time::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 Time::flags() const {
  // @@protoc_insertion_point(field_get:Time.flags)
  return flags_;
}
inline void Time::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:Time.flags)
}

// int64 epoch = 4;
inline void Time::clear_epoch() {
  epoch_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Time::epoch() const {
  // @@protoc_insertion_point(field_get:Time.epoch)
  return epoch_;
}
inline void Time::set_epoch(::google::protobuf::int64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:Time.epoch)
}

// -------------------------------------------------------------------

// Timestamp

// .Time duration = 1;
inline bool Timestamp::has_duration() const {
  return this != internal_default_instance() && duration_ != NULL;
}
inline void Timestamp::clear_duration() {
  if (GetArenaNoVirtual() == NULL && duration_ != NULL) delete duration_;
  duration_ = NULL;
}
inline const ::Time& Timestamp::duration() const {
  const ::Time* p = duration_;
  // @@protoc_insertion_point(field_get:Timestamp.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::Time*>(
      &::_Time_default_instance_);
}
inline ::Time* Timestamp::mutable_duration() {
  
  if (duration_ == NULL) {
    duration_ = new ::Time;
  }
  // @@protoc_insertion_point(field_mutable:Timestamp.duration)
  return duration_;
}
inline ::Time* Timestamp::release_duration() {
  // @@protoc_insertion_point(field_release:Timestamp.duration)
  
  ::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void Timestamp::set_allocated_duration(::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Timestamp.duration)
}

// .Time presentation = 2;
inline bool Timestamp::has_presentation() const {
  return this != internal_default_instance() && presentation_ != NULL;
}
inline void Timestamp::clear_presentation() {
  if (GetArenaNoVirtual() == NULL && presentation_ != NULL) delete presentation_;
  presentation_ = NULL;
}
inline const ::Time& Timestamp::presentation() const {
  const ::Time* p = presentation_;
  // @@protoc_insertion_point(field_get:Timestamp.presentation)
  return p != NULL ? *p : *reinterpret_cast<const ::Time*>(
      &::_Time_default_instance_);
}
inline ::Time* Timestamp::mutable_presentation() {
  
  if (presentation_ == NULL) {
    presentation_ = new ::Time;
  }
  // @@protoc_insertion_point(field_mutable:Timestamp.presentation)
  return presentation_;
}
inline ::Time* Timestamp::release_presentation() {
  // @@protoc_insertion_point(field_release:Timestamp.presentation)
  
  ::Time* temp = presentation_;
  presentation_ = NULL;
  return temp;
}
inline void Timestamp::set_allocated_presentation(::Time* presentation) {
  delete presentation_;
  presentation_ = presentation;
  if (presentation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Timestamp.presentation)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Image

// int64 width = 1;
inline void Image::clear_width() {
  width_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Image::width() const {
  // @@protoc_insertion_point(field_get:Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::int64 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:Image.width)
}

// int64 height = 2;
inline void Image::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Image::height() const {
  // @@protoc_insertion_point(field_get:Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:Image.height)
}

// uint32 format = 3;
inline void Image::clear_format() {
  format_ = 0u;
}
inline ::google::protobuf::uint32 Image::format() const {
  // @@protoc_insertion_point(field_get:Image.format)
  return format_;
}
inline void Image::set_format(::google::protobuf::uint32 value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:Image.format)
}

// map<string, string> attachments = 4;
inline int Image::attachments_size() const {
  return attachments_.size();
}
inline void Image::clear_attachments() {
  attachments_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Image::attachments() const {
  // @@protoc_insertion_point(field_map:Image.attachments)
  return attachments_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Image::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_map:Image.attachments)
  return attachments_.MutableMap();
}

// bytes data = 5;
inline void Image::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:Image.data)
  return data_.GetNoArena();
}
inline void Image::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Image.data)
}
#if LANG_CXX11
inline void Image::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Image.data)
}
#endif
inline void Image::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Image.data)
}
inline void Image::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Image.data)
}
inline ::std::string* Image::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:Image.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:Image.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:Image.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FormatDescription

// uint32 mediaType = 1;
inline void FormatDescription::clear_mediatype() {
  mediatype_ = 0u;
}
inline ::google::protobuf::uint32 FormatDescription::mediatype() const {
  // @@protoc_insertion_point(field_get:FormatDescription.mediaType)
  return mediatype_;
}
inline void FormatDescription::set_mediatype(::google::protobuf::uint32 value) {
  
  mediatype_ = value;
  // @@protoc_insertion_point(field_set:FormatDescription.mediaType)
}

// uint32 mediaSubtype = 2;
inline void FormatDescription::clear_mediasubtype() {
  mediasubtype_ = 0u;
}
inline ::google::protobuf::uint32 FormatDescription::mediasubtype() const {
  // @@protoc_insertion_point(field_get:FormatDescription.mediaSubtype)
  return mediasubtype_;
}
inline void FormatDescription::set_mediasubtype(::google::protobuf::uint32 value) {
  
  mediasubtype_ = value;
  // @@protoc_insertion_point(field_set:FormatDescription.mediaSubtype)
}

// map<string, string> extensions = 3;
inline int FormatDescription::extensions_size() const {
  return extensions_.size();
}
inline void FormatDescription::clear_extensions() {
  extensions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
FormatDescription::extensions() const {
  // @@protoc_insertion_point(field_map:FormatDescription.extensions)
  return extensions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
FormatDescription::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:FormatDescription.extensions)
  return extensions_.MutableMap();
}

// -------------------------------------------------------------------

// VideoSample

// .Image image = 1;
inline bool VideoSample::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void VideoSample::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::Image& VideoSample::image() const {
  const ::Image* p = image_;
  // @@protoc_insertion_point(field_get:VideoSample.image)
  return p != NULL ? *p : *reinterpret_cast<const ::Image*>(
      &::_Image_default_instance_);
}
inline ::Image* VideoSample::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::Image;
  }
  // @@protoc_insertion_point(field_mutable:VideoSample.image)
  return image_;
}
inline ::Image* VideoSample::release_image() {
  // @@protoc_insertion_point(field_release:VideoSample.image)
  
  ::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void VideoSample::set_allocated_image(::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:VideoSample.image)
}

// -------------------------------------------------------------------

// AudioSample

// .Image image = 1;
inline bool AudioSample::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void AudioSample::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::Image& AudioSample::image() const {
  const ::Image* p = image_;
  // @@protoc_insertion_point(field_get:AudioSample.image)
  return p != NULL ? *p : *reinterpret_cast<const ::Image*>(
      &::_Image_default_instance_);
}
inline ::Image* AudioSample::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::Image;
  }
  // @@protoc_insertion_point(field_mutable:AudioSample.image)
  return image_;
}
inline ::Image* AudioSample::release_image() {
  // @@protoc_insertion_point(field_release:AudioSample.image)
  
  ::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void AudioSample::set_allocated_image(::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:AudioSample.image)
}

// -------------------------------------------------------------------

// Av

// .VideoSample video = 1;
inline bool Av::has_video() const {
  return this != internal_default_instance() && video_ != NULL;
}
inline void Av::clear_video() {
  if (GetArenaNoVirtual() == NULL && video_ != NULL) delete video_;
  video_ = NULL;
}
inline const ::VideoSample& Av::video() const {
  const ::VideoSample* p = video_;
  // @@protoc_insertion_point(field_get:Av.video)
  return p != NULL ? *p : *reinterpret_cast<const ::VideoSample*>(
      &::_VideoSample_default_instance_);
}
inline ::VideoSample* Av::mutable_video() {
  
  if (video_ == NULL) {
    video_ = new ::VideoSample;
  }
  // @@protoc_insertion_point(field_mutable:Av.video)
  return video_;
}
inline ::VideoSample* Av::release_video() {
  // @@protoc_insertion_point(field_release:Av.video)
  
  ::VideoSample* temp = video_;
  video_ = NULL;
  return temp;
}
inline void Av::set_allocated_video(::VideoSample* video) {
  delete video_;
  video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Av.video)
}

// .AudioSample audio = 2;
inline bool Av::has_audio() const {
  return this != internal_default_instance() && audio_ != NULL;
}
inline void Av::clear_audio() {
  if (GetArenaNoVirtual() == NULL && audio_ != NULL) delete audio_;
  audio_ = NULL;
}
inline const ::AudioSample& Av::audio() const {
  const ::AudioSample* p = audio_;
  // @@protoc_insertion_point(field_get:Av.audio)
  return p != NULL ? *p : *reinterpret_cast<const ::AudioSample*>(
      &::_AudioSample_default_instance_);
}
inline ::AudioSample* Av::mutable_audio() {
  
  if (audio_ == NULL) {
    audio_ = new ::AudioSample;
  }
  // @@protoc_insertion_point(field_mutable:Av.audio)
  return audio_;
}
inline ::AudioSample* Av::release_audio() {
  // @@protoc_insertion_point(field_release:Av.audio)
  
  ::AudioSample* temp = audio_;
  audio_ = NULL;
  return temp;
}
inline void Av::set_allocated_audio(::AudioSample* audio) {
  delete audio_;
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Av.audio)
}

// -------------------------------------------------------------------

// AVSession

// string sid = 1;
inline void AVSession::clear_sid() {
  sid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AVSession::sid() const {
  // @@protoc_insertion_point(field_get:AVSession.sid)
  return sid_.GetNoArena();
}
inline void AVSession::set_sid(const ::std::string& value) {
  
  sid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AVSession.sid)
}
#if LANG_CXX11
inline void AVSession::set_sid(::std::string&& value) {
  
  sid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AVSession.sid)
}
#endif
inline void AVSession::set_sid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AVSession.sid)
}
inline void AVSession::set_sid(const char* value, size_t size) {
  
  sid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AVSession.sid)
}
inline ::std::string* AVSession::mutable_sid() {
  
  // @@protoc_insertion_point(field_mutable:AVSession.sid)
  return sid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AVSession::release_sid() {
  // @@protoc_insertion_point(field_release:AVSession.sid)
  
  return sid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AVSession::set_allocated_sid(::std::string* sid) {
  if (sid != NULL) {
    
  } else {
    
  }
  sid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sid);
  // @@protoc_insertion_point(field_set_allocated:AVSession.sid)
}

// string gid = 2;
inline void AVSession::clear_gid() {
  gid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AVSession::gid() const {
  // @@protoc_insertion_point(field_get:AVSession.gid)
  return gid_.GetNoArena();
}
inline void AVSession::set_gid(const ::std::string& value) {
  
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AVSession.gid)
}
#if LANG_CXX11
inline void AVSession::set_gid(::std::string&& value) {
  
  gid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AVSession.gid)
}
#endif
inline void AVSession::set_gid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AVSession.gid)
}
inline void AVSession::set_gid(const char* value, size_t size) {
  
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AVSession.gid)
}
inline ::std::string* AVSession::mutable_gid() {
  
  // @@protoc_insertion_point(field_mutable:AVSession.gid)
  return gid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AVSession::release_gid() {
  // @@protoc_insertion_point(field_release:AVSession.gid)
  
  return gid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AVSession::set_allocated_gid(::std::string* gid) {
  if (gid != NULL) {
    
  } else {
    
  }
  gid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gid);
  // @@protoc_insertion_point(field_set_allocated:AVSession.gid)
}

// bool active = 3;
inline void AVSession::clear_active() {
  active_ = false;
}
inline bool AVSession::active() const {
  // @@protoc_insertion_point(field_get:AVSession.active)
  return active_;
}
inline void AVSession::set_active(bool value) {
  
  active_ = value;
  // @@protoc_insertion_point(field_set:AVSession.active)
}

// bytes data = 4;
inline void AVSession::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AVSession::data() const {
  // @@protoc_insertion_point(field_get:AVSession.data)
  return data_.GetNoArena();
}
inline void AVSession::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AVSession.data)
}
#if LANG_CXX11
inline void AVSession::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AVSession.data)
}
#endif
inline void AVSession::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AVSession.data)
}
inline void AVSession::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AVSession.data)
}
inline ::std::string* AVSession::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:AVSession.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AVSession::release_data() {
  // @@protoc_insertion_point(field_release:AVSession.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AVSession::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:AVSession.data)
}

// -------------------------------------------------------------------

// AVQuality

// int32 diff = 1;
inline void AVQuality::clear_diff() {
  diff_ = 0;
}
inline ::google::protobuf::int32 AVQuality::diff() const {
  // @@protoc_insertion_point(field_get:AVQuality.diff)
  return diff_;
}
inline void AVQuality::set_diff(::google::protobuf::int32 value) {
  
  diff_ = value;
  // @@protoc_insertion_point(field_set:AVQuality.diff)
}

// -------------------------------------------------------------------

// Voip

// uint32 version = 1;
inline void Voip::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 Voip::version() const {
  // @@protoc_insertion_point(field_get:Voip.version)
  return version_;
}
inline void Voip::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:Voip.version)
}

// .Voip.Which which = 12;
inline void Voip::clear_which() {
  which_ = 0;
}
inline ::Voip_Which Voip::which() const {
  // @@protoc_insertion_point(field_get:Voip.which)
  return static_cast< ::Voip_Which >(which_);
}
inline void Voip::set_which(::Voip_Which value) {
  
  which_ = value;
  // @@protoc_insertion_point(field_set:Voip.which)
}

// repeated .Text textStorage = 101;
inline int Voip::textstorage_size() const {
  return textstorage_.size();
}
inline void Voip::clear_textstorage() {
  textstorage_.Clear();
}
inline const ::Text& Voip::textstorage(int index) const {
  // @@protoc_insertion_point(field_get:Voip.textStorage)
  return textstorage_.Get(index);
}
inline ::Text* Voip::mutable_textstorage(int index) {
  // @@protoc_insertion_point(field_mutable:Voip.textStorage)
  return textstorage_.Mutable(index);
}
inline ::Text* Voip::add_textstorage() {
  // @@protoc_insertion_point(field_add:Voip.textStorage)
  return textstorage_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Text >*
Voip::mutable_textstorage() {
  // @@protoc_insertion_point(field_mutable_list:Voip.textStorage)
  return &textstorage_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Text >&
Voip::textstorage() const {
  // @@protoc_insertion_point(field_list:Voip.textStorage)
  return textstorage_;
}

// .File file = 102;
inline bool Voip::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline void Voip::clear_file() {
  if (GetArenaNoVirtual() == NULL && file_ != NULL) delete file_;
  file_ = NULL;
}
inline const ::File& Voip::file() const {
  const ::File* p = file_;
  // @@protoc_insertion_point(field_get:Voip.file)
  return p != NULL ? *p : *reinterpret_cast<const ::File*>(
      &::_File_default_instance_);
}
inline ::File* Voip::mutable_file() {
  
  if (file_ == NULL) {
    file_ = new ::File;
  }
  // @@protoc_insertion_point(field_mutable:Voip.file)
  return file_;
}
inline ::File* Voip::release_file() {
  // @@protoc_insertion_point(field_release:Voip.file)
  
  ::File* temp = file_;
  file_ = NULL;
  return temp;
}
inline void Voip::set_allocated_file(::File* file) {
  delete file_;
  file_ = file;
  if (file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Voip.file)
}

// bytes payload = 103;
inline void Voip::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Voip::payload() const {
  // @@protoc_insertion_point(field_get:Voip.payload)
  return payload_.GetNoArena();
}
inline void Voip::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Voip.payload)
}
#if LANG_CXX11
inline void Voip::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Voip.payload)
}
#endif
inline void Voip::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Voip.payload)
}
inline void Voip::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Voip.payload)
}
inline ::std::string* Voip::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:Voip.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Voip::release_payload() {
  // @@protoc_insertion_point(field_release:Voip.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Voip::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:Voip.payload)
}

// .Call call = 104;
inline bool Voip::has_call() const {
  return this != internal_default_instance() && call_ != NULL;
}
inline void Voip::clear_call() {
  if (GetArenaNoVirtual() == NULL && call_ != NULL) delete call_;
  call_ = NULL;
}
inline const ::Call& Voip::call() const {
  const ::Call* p = call_;
  // @@protoc_insertion_point(field_get:Voip.call)
  return p != NULL ? *p : *reinterpret_cast<const ::Call*>(
      &::_Call_default_instance_);
}
inline ::Call* Voip::mutable_call() {
  
  if (call_ == NULL) {
    call_ = new ::Call;
  }
  // @@protoc_insertion_point(field_mutable:Voip.call)
  return call_;
}
inline ::Call* Voip::release_call() {
  // @@protoc_insertion_point(field_release:Voip.call)
  
  ::Call* temp = call_;
  call_ = NULL;
  return temp;
}
inline void Voip::set_allocated_call(::Call* call) {
  delete call_;
  call_ = call;
  if (call) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Voip.call)
}

// .Av av = 105;
inline bool Voip::has_av() const {
  return this != internal_default_instance() && av_ != NULL;
}
inline void Voip::clear_av() {
  if (GetArenaNoVirtual() == NULL && av_ != NULL) delete av_;
  av_ = NULL;
}
inline const ::Av& Voip::av() const {
  const ::Av* p = av_;
  // @@protoc_insertion_point(field_get:Voip.av)
  return p != NULL ? *p : *reinterpret_cast<const ::Av*>(
      &::_Av_default_instance_);
}
inline ::Av* Voip::mutable_av() {
  
  if (av_ == NULL) {
    av_ = new ::Av;
  }
  // @@protoc_insertion_point(field_mutable:Voip.av)
  return av_;
}
inline ::Av* Voip::release_av() {
  // @@protoc_insertion_point(field_release:Voip.av)
  
  ::Av* temp = av_;
  av_ = NULL;
  return temp;
}
inline void Voip::set_allocated_av(::Av* av) {
  delete av_;
  av_ = av;
  if (av) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Voip.av)
}

// .AVSession audioSession = 106;
inline bool Voip::has_audiosession() const {
  return this != internal_default_instance() && audiosession_ != NULL;
}
inline void Voip::clear_audiosession() {
  if (GetArenaNoVirtual() == NULL && audiosession_ != NULL) delete audiosession_;
  audiosession_ = NULL;
}
inline const ::AVSession& Voip::audiosession() const {
  const ::AVSession* p = audiosession_;
  // @@protoc_insertion_point(field_get:Voip.audioSession)
  return p != NULL ? *p : *reinterpret_cast<const ::AVSession*>(
      &::_AVSession_default_instance_);
}
inline ::AVSession* Voip::mutable_audiosession() {
  
  if (audiosession_ == NULL) {
    audiosession_ = new ::AVSession;
  }
  // @@protoc_insertion_point(field_mutable:Voip.audioSession)
  return audiosession_;
}
inline ::AVSession* Voip::release_audiosession() {
  // @@protoc_insertion_point(field_release:Voip.audioSession)
  
  ::AVSession* temp = audiosession_;
  audiosession_ = NULL;
  return temp;
}
inline void Voip::set_allocated_audiosession(::AVSession* audiosession) {
  delete audiosession_;
  audiosession_ = audiosession;
  if (audiosession) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Voip.audioSession)
}

// .AVSession videoSession = 107;
inline bool Voip::has_videosession() const {
  return this != internal_default_instance() && videosession_ != NULL;
}
inline void Voip::clear_videosession() {
  if (GetArenaNoVirtual() == NULL && videosession_ != NULL) delete videosession_;
  videosession_ = NULL;
}
inline const ::AVSession& Voip::videosession() const {
  const ::AVSession* p = videosession_;
  // @@protoc_insertion_point(field_get:Voip.videoSession)
  return p != NULL ? *p : *reinterpret_cast<const ::AVSession*>(
      &::_AVSession_default_instance_);
}
inline ::AVSession* Voip::mutable_videosession() {
  
  if (videosession_ == NULL) {
    videosession_ = new ::AVSession;
  }
  // @@protoc_insertion_point(field_mutable:Voip.videoSession)
  return videosession_;
}
inline ::AVSession* Voip::release_videosession() {
  // @@protoc_insertion_point(field_release:Voip.videoSession)
  
  ::AVSession* temp = videosession_;
  videosession_ = NULL;
  return temp;
}
inline void Voip::set_allocated_videosession(::AVSession* videosession) {
  delete videosession_;
  videosession_ = videosession;
  if (videosession) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Voip.videoSession)
}

// .AVQuality avQuality = 18;
inline bool Voip::has_avquality() const {
  return this != internal_default_instance() && avquality_ != NULL;
}
inline void Voip::clear_avquality() {
  if (GetArenaNoVirtual() == NULL && avquality_ != NULL) delete avquality_;
  avquality_ = NULL;
}
inline const ::AVQuality& Voip::avquality() const {
  const ::AVQuality* p = avquality_;
  // @@protoc_insertion_point(field_get:Voip.avQuality)
  return p != NULL ? *p : *reinterpret_cast<const ::AVQuality*>(
      &::_AVQuality_default_instance_);
}
inline ::AVQuality* Voip::mutable_avquality() {
  
  if (avquality_ == NULL) {
    avquality_ = new ::AVQuality;
  }
  // @@protoc_insertion_point(field_mutable:Voip.avQuality)
  return avquality_;
}
inline ::AVQuality* Voip::release_avquality() {
  // @@protoc_insertion_point(field_release:Voip.avQuality)
  
  ::AVQuality* temp = avquality_;
  avquality_ = NULL;
  return temp;
}
inline void Voip::set_allocated_avquality(::AVQuality* avquality) {
  delete avquality_;
  avquality_ = avquality;
  if (avquality) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Voip.avQuality)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Voip_Which> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Voip_Which>() {
  return ::Voip_Which_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_voip_2eproto__INCLUDED
